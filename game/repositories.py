from sqlalchemy import text, or_, func, and_from sqlalchemy.dialects import postgresqlfrom game.entities import User, Area, World, Countryfrom engine.modules.auth.repository import AbstractUserRepositoryfrom engine.modules.worlds.repository import AbstractWorldInstanceRepositoryfrom engine.repository import Repository, Entity@Entity(User)class UserRepository(AbstractUserRepository):    def set_world(self, uid, wid, iso):        sq = self.session.query(User)        self.session.query(User)\            .filter(User.uid == uid)\            .update({User.wid: wid, User.iso: iso})        #self.session.commit()    def list_all(self, wid):        return self.session.query(self.T)\            .filter(self.T == wid)\        .all()@Entity(World)class WorldRepository(Repository):    def get_first(self):        return self.session.query(World).first()@Entity(Country)class CountryRepository(AbstractWorldInstanceRepository):    def list_all(self, wid=None):        return self.session.query(Country)\            .filter(Country.wid == wid)\            .order_by(Country.order)\        .all()    def set_payday(self, wid):        SQL = """        WITH yields AS (SELECT iso, sum(CASE WHEN build = 'cita' THEN 30 ELSE 10 END) as tax          FROM areas          WHERE wid = :wid          GROUP BY iso),                UPDATE countries SET gold = gold + tax        FROM yields        WHERE yields.iso = countries.iso AND countries.wid = :wid        RETURNING countries.iso as iso, tax;        """        result = self.session.execute(text(SQL), {'wid': wid}).fetchall()        self.session.commit()        return {row['iso']: row['tax'] for row in result}    def set_pop(self, wid):        SQL = """        WITH stats AS (SELECT iso,             sum(CASE WHEN build = 'barr' THEN 3 ELSE 1 END) as pop_limit,             sum(CASE WHEN unit IS NOT null THEN 1 ELSE 0 END) as mil_pop          FROM areas          WHERE wid = :wid          GROUP BY iso)                UPDATE countries        SET pop = pop_limit - mil_pop        FROM stats        WHERE countries.iso = stats.iso AND countries.wid = :wid        RETURNING countries.iso as iso, pop;        """        result = self.session.execute(text(SQL), {'wid': wid}).fetchall()        self.session.commit()        return {row['iso']: row['pop'] for row in result}    def list_still_playing(self, wid):        """Gets countries that are eliminated from the game:        - game ends for player: when shields == 0        - when country has no city or unit area        So countries are still playing if:        - their shields > 0        - they have any area with units or city tiles on it        """        SQL = """        SELECT c.iso        FROM countries c        LEFT JOIN areas a          ON a.iso = c.iso --AND a.wid = :wid AND c.wid = :wid         WHERE a.iso IS NOT NULL        AND (tile = 'city' OR a.unit IS NOT NULL)        AND c.shields > 0        GROUP BY c.iso        """        return self.session.execute(text(SQL), {'wid': wid}).fetchall()@Entity(Area)class AreaRepository(AbstractWorldInstanceRepository):    def list(self, ids):        return self.session.query(Area)\            .filter(Area.id.in_(ids))\        .all()    def list_empty(self, wid):        """Gets area isos without an army or cities"""        return self.session.query(Area.iso, func.count())\            .filter(Area.wid == wid, Area.iso != None)\            .filter(or_(Area.tile == 'city', Area.unit != None))\            .group_by(Area.iso)\            .having(func.count() == 0)\        .all()    def set_decrement_exhaust(self, wid):        self.session.query(Area)\            .filter(Area.wid == wid, Area.exhaust > 0)\            .update({Area.exhaust: Area.exhaust - 1})        #synchronize_session=False        #self.session.commit()